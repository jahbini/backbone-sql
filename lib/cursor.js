// Generated by CoffeeScript 1.9.2

/*
  backbone-sql.js 0.6.5
  Copyright (c) 2013 Vidigami - https://github.com/vidigami/backbone-sql
  License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

(function() {
  var COMPARATORS, COMPARATOR_KEYS, Knex, SqlCursor, _, _appendCondition, _appendConditionalWhere, _appendWhere, _columnName, _extractCount, ref, sync,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Knex = require('knex');

  ref = require('backbone-orm'), _ = ref._, sync = ref.sync;

  COMPARATORS = {
    $lt: '<',
    $lte: '<=',
    $gt: '>',
    $gte: '>=',
    $ne: '!='
  };

  COMPARATOR_KEYS = _.keys(COMPARATORS);

  _appendCondition = function(conditions, key, value) {
    var mongo_op, mongo_ops, operations, ops_length, parameter, ref1, ref2;
    if (value != null ? value.$in : void 0) {
      if ((ref1 = value.$in) != null ? ref1.length : void 0) {
        conditions.wheres.push({
          method: 'whereIn',
          key: key,
          value: value.$in
        });
      } else {
        conditions.abort = true;
        return conditions;
      }
    } else if (value != null ? value.$nin : void 0) {
      if ((ref2 = value.$nin) != null ? ref2.length : void 0) {
        conditions.wheres.push({
          method: 'whereNotIn',
          key: key,
          value: value.$nin
        });
      }
    } else if ((value != null ? value.$exists : void 0) != null) {
      conditions.wheres.push({
        method: ((value != null ? value.$exists : void 0) ? 'whereNotNull' : 'whereNull'),
        key: key
      });
    } else if (_.isObject(value) && (ops_length = _.size(mongo_ops = _.pick(value, COMPARATOR_KEYS)))) {
      operations = [];
      for (mongo_op in mongo_ops) {
        parameter = mongo_ops[mongo_op];
        if (_.isNull(value) && (operator !== '$ne')) {
          throw new Error("Unexpected null with query key '" + key + "' operator '" + operator + "'");
        }
        operations.push({
          operator: COMPARATORS[mongo_op],
          value: parameter
        });
      }
      if (ops_length === 1) {
        conditions.where_conditionals.push(_.extend(operations[0], {
          key: key
        }));
      } else {
        conditions.where_conditionals.push({
          key: key,
          operations: operations
        });
      }
    } else {
      conditions.wheres.push({
        key: key,
        value: value
      });
    }
    return conditions;
  };

  _columnName = function(col, table) {
    if (table) {
      return table + "." + col;
    } else {
      return col;
    }
  };

  _appendConditionalWhere = function(query, key, condition, table, compound) {
    var whereMethod;
    whereMethod = compound ? 'andWhere' : 'where';
    if (condition.operator === '!=') {
      return query[whereMethod](function() {
        if (_.isNull(condition.value)) {
          return this.whereNotNull(_columnName(key, table));
        } else {
          return this.where(_columnName(key, table), condition.operator, condition.value).orWhereNull(_columnName(key, table));
        }
      });
    } else {
      return query[whereMethod](_columnName(key, table), condition.operator, condition.value);
    }
  };

  _appendWhere = function(query, conditions, table) {
    var condition, i, j, len, len1, ref1, ref2;
    ref1 = conditions.wheres;
    for (i = 0, len = ref1.length; i < len; i++) {
      condition = ref1[i];
      if (condition.method) {
        query[condition.method](_columnName(condition.key, table), condition.value);
      } else if (_.isNull(condition.value)) {
        query.whereNull(_columnName(condition.key, table));
      } else {
        query.where(_columnName(condition.key, table), condition.value);
      }
    }
    ref2 = conditions.where_conditionals;
    for (j = 0, len1 = ref2.length; j < len1; j++) {
      condition = ref2[j];
      if (condition.operations) {
        query.where(function() {
          var k, len2, nested_query, operation, ref3, results;
          operation = condition.operations.pop();
          nested_query = this;
          _appendConditionalWhere(nested_query, condition.key, operation, table, false);
          ref3 = condition.operations;
          results = [];
          for (k = 0, len2 = ref3.length; k < len2; k++) {
            operation = ref3[k];
            results.push(_appendConditionalWhere(nested_query, condition.key, operation, table, true));
          }
          return results;
        });
      } else if (_.isNull(condition.value)) {
        query.whereNotNull(_columnName(condition.key, table));
      } else {
        _appendConditionalWhere(query, condition.key, condition, table, false);
      }
    }
    return query;
  };

  _extractCount = function(count_json) {
    var count_info;
    if (!(count_json != null ? count_json.length : void 0)) {
      return 0;
    }
    count_info = count_json[0];
    return +count_info[count_info.hasOwnProperty('count(*)') ? 'count(*)' : 'count'];
  };

  module.exports = SqlCursor = (function(superClass) {
    extend(SqlCursor, superClass);

    function SqlCursor() {
      this._exec = bind(this._exec, this);
      return SqlCursor.__super__.constructor.apply(this, arguments);
    }

    SqlCursor.prototype.verbose = false;

    SqlCursor.prototype._parseConditions = function(find, cursor) {
      var base, conditions, key, name, ref1, related_conditions, related_wheres, relation, reverse_relation, value;
      conditions = {
        wheres: [],
        where_conditionals: [],
        related_wheres: {},
        joined_wheres: {}
      };
      related_wheres = {};
      for (key in find) {
        value = find[key];
        if (_.isUndefined(value)) {
          throw new Error("Unexpected undefined for query key '" + key + "'");
        }
        if (key.indexOf('.') > 0) {
          ref1 = key.split('.'), relation = ref1[0], key = ref1[1];
          related_wheres[relation] || (related_wheres[relation] = {});
          related_wheres[relation][key] = value;
        } else if ((reverse_relation = this.model_type.reverseRelation(key)) && reverse_relation.join_table) {
          relation = reverse_relation.reverse_relation;
          (base = conditions.joined_wheres)[name = relation.key] || (base[name] = {
            wheres: [],
            where_conditionals: []
          });
          _appendCondition(conditions.joined_wheres[relation.key], key, value);
        } else {
          _appendCondition(conditions, key, value);
        }
      }
      for (relation in related_wheres) {
        related_conditions = related_wheres[relation];
        conditions.related_wheres[relation] = this._parseConditions(related_conditions);
      }
      if (cursor != null ? cursor.$ids : void 0) {
        if (!cursor.$ids.length) {
          conditions.abort = true;
          return conditions;
        }
        conditions.wheres.push({
          method: 'whereIn',
          key: 'id',
          value: cursor.$ids
        });
      }
      return conditions;
    };

    SqlCursor.prototype.queryToJSON = function(callback) {
      var $columns, $fields, base, err, from_columns, i, key, len, query, rank_field, ref1, ref2, ref3, related_model_type, related_wheres, relation, sort_dir, sort_field, subquery, to_columns;
      if (this.hasCursorQuery('$zero')) {
        return callback(null, this.hasCursorQuery('$one') ? null : []);
      }
      try {
        query = this.connection(this.model_type.tableName());
        this._conditions = this._parseConditions(this._find, this._cursor);
        if (this._conditions.abort) {
          return callback(null, this._cursor.$count ? 0 : (this._cursor.$one ? null : []));
        }
        _appendWhere(query, this._conditions, this.model_type.tableName());
      } catch (_error) {
        err = _error;
        return callback("Query failed for model: " + this.model_type.model_name + " with error: " + err);
      }
      if (this._cursor.$sort) {
        this._cursor.$sort = _.isArray(this._cursor.$sort) ? this._cursor.$sort : [this._cursor.$sort];
      }
      if (this._cursor.$values) {
        $fields = this._cursor.$white_list ? _.intersection(this._cursor.$values, this._cursor.$white_list) : this._cursor.$values;
      } else if (this._cursor.$select) {
        $fields = this._cursor.$white_list ? _.intersection(this._cursor.$select, this._cursor.$white_list) : this._cursor.$select;
      } else if (this._cursor.$white_list) {
        $fields = this._cursor.$white_list;
      }
      if (this._cursor.$unique) {
        $fields || ($fields = this._columns(this.model_type, $fields));
        if (this.hasCursorQuery('$count')) {
          query.count().from(this.connection.distinct(this._cursor.$unique).from(this.model_type.tableName()).as('count_query'));
          return query.exec((function(_this) {
            return function(err, count_json) {
              return callback(err, _extractCount(count_json));
            };
          })(this));
        }
        if (_.difference($fields, this._cursor.$unique).length === 0) {
          query.distinct($fields);
        } else {
          (base = this._cursor).$sort || (base.$sort = []);
          rank_field = this._cursor.$unique[0];
          ref2 = this._parseSortField(((ref1 = this._cursor.$sort) != null ? ref1[0] : void 0) || 'id'), sort_field = ref2[0], sort_dir = ref2[1];
          subquery = this.connection.select(this.connection.raw(($fields.join(', ')) + ", rank() over (partition by " + rank_field + " order by " + sort_field + " " + sort_dir + ")"));
          subquery.from(this.model_type.tableName()).as('subquery');
          query.select($fields).from(subquery).where('rank', 1);
        }
        this._appendSort(query);
        this._appendLimits(query);
        return this._exec(query, callback);
      }
      if (this.hasCursorQuery('$count') || this.hasCursorQuery('$exists')) {
        this._appendRelatedWheres(query);
        this._appendJoinedWheres(query);
        if (this.hasCursorQuery('$count')) {
          return query.count('*').exec((function(_this) {
            return function(err, count_json) {
              return callback(null, _extractCount(count_json));
            };
          })(this));
        } else {
          return query.count('*').limit(1).exec((function(_this) {
            return function(err, count_json) {
              return callback(null, _extractCount(count_json) > 0);
            };
          })(this));
        }
      }
      if (this._cursor.$include) {
        this.include_keys = _.isArray(this._cursor.$include) ? this._cursor.$include : [this._cursor.$include];
        if (!this.include_keys.length) {
          throw Error("Invalid include specified: " + this.include_keys);
        }
        this.joined = true;
        to_columns = [];
        ref3 = this.include_keys;
        for (i = 0, len = ref3.length; i < len; i++) {
          key = ref3[i];
          relation = this._getRelation(key);
          related_model_type = relation.reverse_relation.model_type;
          to_columns = to_columns.concat(this._prefixColumns(related_model_type));
          this._joinTo(query, relation);
          if (related_wheres = this._conditions.related_wheres[key]) {
            (this.queued_queries || (this.queued_queries = [])).push(key);
            _appendWhere(query, related_wheres, related_model_type.tableName());
          }
        }
        from_columns = this._prefixColumns(this.model_type, $fields);
        $columns = from_columns.concat(to_columns);
      } else {
        this._appendLimits(query);
      }
      this._appendRelatedWheres(query);
      this._appendJoinedWheres(query);
      $columns || ($columns = this.joined ? this._prefixColumns(this.model_type, $fields) : this._columns(this.model_type, $fields));
      query.select($columns);
      this._appendSort(query);
      return this._exec(query, callback);
    };

    SqlCursor.prototype._exec = function(query, callback) {
      if (this.verbose) {
        console.log('\n----------');
        console.log(query.toString());
        console.log('----------');
      }
      return query.exec((function(_this) {
        return function(err, json) {
          if (err) {
            return callback(new Error("Query failed for model: " + _this.model_type.model_name + " with error: " + err));
          }
          if (_this.joined) {
            json = _this._joinedResultsToJSON(json);
          }
          if (_this.queued_queries) {
            return _this._appendCompleteRelations(json, callback);
          } else {
            return _this._processResponse(json, callback);
          }
        };
      })(this));
    };

    SqlCursor.prototype._processResponse = function(json, callback) {
      var i, len, model_json, number, query, schema, subquery;
      schema = this.model_type.schema();
      for (i = 0, len = json.length; i < len; i++) {
        model_json = json[i];
        this.backbone_adapter.nativeToAttributes(model_json, schema);
      }
      json = this.selectResults(json);
      if (this._cursor.$include) {
        if (this._cursor.$offset) {
          number = json.length - this._cursor.$offset;
          if (number < 0) {
            number = 0;
          }
          json = number ? json.slice(this._cursor.$offset, this._cursor.$offset + number) : [];
        }
        if (this._cursor.$limit) {
          json = json.splice(0, Math.min(json.length, this._cursor.$limit));
        }
      }
      if (this.hasCursorQuery('$page')) {
        query = this.connection();
        _appendWhere(query, this._conditions, this.model_type.tableName());
        this._appendRelatedWheres(query);
        this._appendJoinedWheres(query);
        if (this._cursor.$unique) {
          subquery = this.connection.distinct(this._cursor.$unique);
          subquery.from(this.model_type.tableName()).as('subquery');
          query.from(subquery);
        } else {
          query.from(this.model_type.tableName());
        }
        query.count('*');
        if (this.verbose) {
          console.log('\n---------- counting rows for $page');
          console.log(query.toString());
          console.log('----------');
        }
        return query.exec((function(_this) {
          return function(err, count_json) {
            if (err) {
              return callback(err);
            }
            return callback(null, {
              offset: _this._cursor.$offset || 0,
              total_rows: _extractCount(count_json),
              rows: json
            });
          };
        })(this));
      } else {
        return callback(null, json);
      }
    };

    SqlCursor.prototype._appendLimits = function(query) {
      if (this._cursor.$one) {
        query.limit(1);
      }
      if (this._cursor.$limit) {
        query.limit(this._cursor.$limit);
      }
      if (this._cursor.$offset) {
        query.offset(this._cursor.$offset);
      }
      return query;
    };

    SqlCursor.prototype._parseSortField = function(sort) {
      var col, dir;
      if (sort[0] === '-') {
        dir = 'desc';
        col = sort.substr(1);
      } else {
        dir = 'asc';
        col = sort;
      }
      return [col, dir];
    };

    SqlCursor.prototype._appendSort = function(query) {
      var col, dir, i, len, ref1, ref2, sort;
      if (!this._cursor.$sort) {
        return query;
      }
      ref1 = this._cursor.$sort;
      for (i = 0, len = ref1.length; i < len; i++) {
        sort = ref1[i];
        ref2 = this._parseSortField(sort), col = ref2[0], dir = ref2[1];
        query.orderBy(col, dir);
      }
      return query;
    };

    SqlCursor.prototype._appendCompleteRelations = function(json, callback) {
      var i, key, len, new_query, ref1, related_model_type, relation, to_columns;
      new_query = this.connection(this.model_type.tableName());
      new_query.whereIn(_columnName('id', this.model_type.tableName()), _.pluck(json, 'id'));
      to_columns = [];
      ref1 = this.queued_queries;
      for (i = 0, len = ref1.length; i < len; i++) {
        key = ref1[i];
        relation = this._getRelation(key);
        related_model_type = relation.reverse_relation.model_type;
        to_columns = to_columns.concat(this._prefixColumns(related_model_type));
        this._joinTo(new_query, relation);
      }
      new_query.select((this._prefixColumns(this.model_type, ['id'])).concat(to_columns));
      return new_query.exec((function(_this) {
        return function(err, new_json) {
          var j, len1, model, placeholder, relation_json;
          if (err) {
            return callback(err);
          }
          relation_json = _this._joinedResultsToJSON(new_json);
          for (j = 0, len1 = relation_json.length; j < len1; j++) {
            placeholder = relation_json[j];
            model = _.find(json, function(test) {
              return test.id === placeholder.id;
            });
            _.extend(model, placeholder);
          }
          return _this._processResponse(json, callback);
        };
      })(this));
    };

    SqlCursor.prototype._appendRelatedWheres = function(query) {
      var key, ref1, related_wheres, relation, results;
      if (_.isEmpty(this._conditions.related_wheres)) {
        return;
      }
      this.joined = true;
      if (this.include_keys) {
        this._conditions.related_wheres = _.omit(this._conditions.related_wheres, this.include_keys);
      }
      ref1 = this._conditions.related_wheres;
      results = [];
      for (key in ref1) {
        related_wheres = ref1[key];
        relation = this._getRelation(key);
        this._joinTo(query, relation);
        results.push(_appendWhere(query, related_wheres, relation.reverse_relation.model_type.tableName()));
      }
      return results;
    };

    SqlCursor.prototype._appendJoinedWheres = function(query) {
      var from_key, joined_wheres, key, ref1, relation, results, to_key;
      if (_.isEmpty(this._conditions.joined_wheres)) {
        return;
      }
      this.joined = true;
      ref1 = this._conditions.joined_wheres;
      results = [];
      for (key in ref1) {
        joined_wheres = ref1[key];
        relation = this._getRelation(key);
        if (!(indexOf.call(_.keys(this._conditions.related_wheres), key) >= 0 || (this.include_keys && indexOf.call(this.include_keys, key) >= 0))) {
          from_key = (this.model_type.tableName()) + ".id";
          to_key = (relation.join_table.tableName()) + "." + relation.foreign_key;
          query.join(relation.join_table.tableName(), from_key, '=', to_key, 'left outer');
        }
        results.push(_appendWhere(query, joined_wheres, relation.join_table.tableName()));
      }
      return results;
    };

    SqlCursor.prototype._joinTo = function(query, relation) {
      var from_key, pivot_from_key, pivot_table, pivot_to_key, related_model_type, to_key;
      related_model_type = relation.reverse_relation.model_type;
      if (relation.type === 'hasMany' && relation.reverse_relation.type === 'hasMany') {
        pivot_table = relation.join_table.tableName();
        from_key = (this.model_type.tableName()) + ".id";
        pivot_to_key = pivot_table + "." + relation.foreign_key;
        query.join(pivot_table, from_key, '=', pivot_to_key, 'left outer');
        pivot_from_key = pivot_table + "." + relation.reverse_relation.foreign_key;
        to_key = (related_model_type.tableName()) + ".id";
        return query.join(related_model_type.tableName(), pivot_from_key, '=', to_key, 'left outer');
      } else {
        if (relation.type === 'belongsTo') {
          from_key = (this.model_type.tableName()) + "." + relation.foreign_key;
          to_key = (related_model_type.tableName()) + ".id";
        } else {
          from_key = (this.model_type.tableName()) + ".id";
          to_key = (related_model_type.tableName()) + "." + relation.foreign_key;
        }
        return query.join(related_model_type.tableName(), from_key, '=', to_key, 'left outer');
      }
    };

    SqlCursor.prototype._joinedResultsToJSON = function(raw_json) {
      var found, i, include_key, j, json, key, len, len1, match, model_json, ref1, related_json, related_model_type, reverse_relation_schema, row, row_relation_json, value;
      if (!(raw_json && raw_json.length)) {
        return raw_json;
      }
      json = [];
      for (i = 0, len = raw_json.length; i < len; i++) {
        row = raw_json[i];
        model_json = {};
        row_relation_json = {};
        for (key in row) {
          value = row[key];
          if (match = this._prefixRegex(this.model_type).exec(key)) {
            model_json[match[1]] = value;
          } else if (this.include_keys) {
            ref1 = this.include_keys;
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              include_key = ref1[j];
              related_json = (row_relation_json[include_key] || (row_relation_json[include_key] = {}));
              related_model_type = this.model_type.relation(include_key).reverse_relation.model_type;
              if (match = this._prefixRegex(related_model_type).exec(key)) {
                related_json[match[1]] = value;
              }
            }
          }
        }
        if (found = _.find(json, function(test) {
          return test.id === model_json.id;
        })) {
          model_json = found;
        } else {
          json.push(model_json);
        }
        for (include_key in row_relation_json) {
          related_json = row_relation_json[include_key];
          if (_.isNull(related_json.id)) {
            if (this.model_type.relation(include_key).type === 'hasMany') {
              model_json[include_key] = [];
            } else {
              model_json[include_key] = null;
            }
          } else if (!_.isEmpty(related_json)) {
            reverse_relation_schema = this.model_type.relation(include_key).reverse_relation.model_type.schema();
            related_json = this.backbone_adapter.nativeToAttributes(related_json, reverse_relation_schema);
            if (this.model_type.relation(include_key).type === 'hasMany') {
              model_json[include_key] || (model_json[include_key] = []);
              if (!_.find(model_json[include_key], function(test) {
                return test.id === related_json.id;
              })) {
                model_json[include_key].push(related_json);
              }
            } else {
              model_json[include_key] = related_json;
            }
          }
        }
      }
      return json;
    };

    SqlCursor.prototype._columns = function(model_type, fields) {
      var columns;
      columns = fields ? _.clone(fields) : model_type.schema().columns();
      if (indexOf.call(columns, 'id') < 0) {
        columns.push('id');
      }
      return columns;
    };

    SqlCursor.prototype._prefixColumns = function(model_type, fields) {
      var col, columns;
      columns = fields ? _.clone(fields) : model_type.schema().columns();
      if (indexOf.call(columns, 'id') < 0) {
        columns.push('id');
      }
      return (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = columns.length; i < len; i++) {
          col = columns[i];
          results.push((model_type.tableName()) + "." + col + " as " + (this._tablePrefix(model_type)) + col);
        }
        return results;
      }).call(this);
    };

    SqlCursor.prototype._tablePrefix = function(model_type) {
      return (model_type.tableName()) + "_";
    };

    SqlCursor.prototype._prefixRegex = function(model_type) {
      return new RegExp("^" + (this._tablePrefix(model_type)) + "(.*)$");
    };

    SqlCursor.prototype._getRelation = function(key) {
      var relation;
      if (!(relation = this.model_type.relation(key))) {
        throw new Error(key + " is not a relation of " + this.model_type.model_name);
      }
      return relation;
    };

    return SqlCursor;

  })(sync.Cursor);

}).call(this);
