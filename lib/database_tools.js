// Generated by CoffeeScript 1.7.1

/*
  backbone-sql.js 0.6.4
  Copyright (c) 2013 Vidigami - https://github.com/vidigami/backbone-sql
  License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

(function() {
  var DatabaseTools, KNEX_COLUMN_OPTIONS, KNEX_SKIP, KNEX_TYPES, Knex, Queue, knex_helpers, _, _deprecate, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Knex = require('knex');

  _ref = require('backbone-orm'), _ = _ref._, Queue = _ref.Queue;

  KNEX_COLUMN_OPTIONS = ['textType', 'length', 'precision', 'scale', 'value', 'values'];

  knex_helpers = require('knex/lib/helpers');

  KNEX_SKIP = ['The five argument join'];

  _deprecate = knex_helpers.deprecate;

  knex_helpers.deprecate = function(msg) {
    if (msg.indexOf(KNEX_SKIP) !== 0) {
      return _deprecate.apply(this, _.toArray(arguments));
    }
  };

  KNEX_TYPES = {
    datetime: 'dateTime',
    biginteger: 'bigInteger'
  };

  module.exports = DatabaseTools = (function() {
    function DatabaseTools(connection, table_name, schema, options) {
      this.connection = connection;
      this.table_name = table_name;
      this.schema = schema;
      if (options == null) {
        options = {};
      }
      this.renameTable = __bind(this.renameTable, this);
      this.dropTableIfExists = __bind(this.dropTableIfExists, this);
      this.dropTable = __bind(this.dropTable, this);
      this.hasTable = __bind(this.hasTable, this);
      this.hasColumn = __bind(this.hasColumn, this);
      this.updateColumn = __bind(this.updateColumn, this);
      this.addColumn = __bind(this.addColumn, this);
      this.createOrUpdateTable = __bind(this.createOrUpdateTable, this);
      this.ensureSchema = __bind(this.ensureSchema, this);
      this.resetSchema = __bind(this.resetSchema, this);
    }

    DatabaseTools.prototype.resetSchema = function(options, callback) {
      var queue, _ref1;
      if (arguments.length === 1) {
        _ref1 = [options, {}], callback = _ref1[0], options = _ref1[1];
      }
      if (this.resetting) {
        return callback();
      }
      this.resetting = true;
      queue = new Queue(1);
      queue.defer((function(_this) {
        return function(callback) {
          return _this.connection.knex().schema.dropTableIfExists(_this.table_name).exec(callback);
        };
      })(this));
      queue.defer((function(_this) {
        return function(callback) {
          var join_queue, join_table, _fn, _i, _len, _ref2;
          join_queue = new Queue(1);
          _ref2 = _this.schema.joinTables();
          _fn = function(join_table) {
            return join_queue.defer(function(callback) {
              return join_table.db().resetSchema(callback);
            });
          };
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            join_table = _ref2[_i];
            _fn(join_table);
          }
          return join_queue.await(callback);
        };
      })(this));
      return queue.await((function(_this) {
        return function(err) {
          _this.resetting = false;
          if (err) {
            return callback(err);
          }
          return _this.ensureSchema(options, callback);
        };
      })(this));
    };

    DatabaseTools.prototype.ensureSchema = function(options, callback) {
      var queue, _ref1;
      if (arguments.length === 1) {
        _ref1 = [options, {}], callback = _ref1[0], options = _ref1[1];
      }
      if (this.ensuring) {
        return callback();
      }
      this.ensuring = true;
      queue = new Queue(1);
      queue.defer((function(_this) {
        return function(callback) {
          return _this.createOrUpdateTable(options, callback);
        };
      })(this));
      queue.defer((function(_this) {
        return function(callback) {
          var join_queue, join_table, _fn, _i, _len, _ref2;
          join_queue = new Queue(1);
          _ref2 = _this.schema.joinTables();
          _fn = function(join_table) {
            return join_queue.defer(function(callback) {
              return join_table.db().ensureSchema(callback);
            });
          };
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            join_table = _ref2[_i];
            _fn(join_table);
          }
          return join_queue.await(callback);
        };
      })(this));
      return queue.await((function(_this) {
        return function(err) {
          _this.ensuring = false;
          return callback(err);
        };
      })(this));
    };

    DatabaseTools.prototype.createOrUpdateTable = function(options, callback) {
      this.hasTable((function(_this) {
        return function(err, table_exists) {
          var columns, field, group, key, override, relation, type, _i, _len, _ref1, _ref2;
          if (err) {
            return callback(err);
          }
          if (options.verbose) {
            console.log("Ensuring table: " + _this.table_name + " (exists: " + (!!table_exists) + ") with fields: '" + (_.keys(_this.schema.fields).join(', ')) + "' and relations: '" + (_.keys(_this.schema.relations).join(', ')) + "'");
          }
          columns = [];
          _ref1 = _this.schema.columns();
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            key = _ref1[_i];
            if (field = _this.schema.fields[key]) {
              if (override = KNEX_TYPES[type = field.type.toLowerCase()]) {
                type = override;
              }
              columns.push({
                key: key,
                type: type,
                options: field
              });
            } else if (key === 'id') {
              columns.push({
                key: key,
                type: 'increments',
                options: {
                  indexed: true,
                  primary: true
                }
              });
            }
          }
          _ref2 = _this.schema.relations;
          for (key in _ref2) {
            relation = _ref2[key];
            if ((relation.type === 'belongsTo') && !relation.isVirtual() && !relation.isEmbedded()) {
              (function(key, relation) {
                return columns.push({
                  key: relation.foreign_key,
                  type: 'integer',
                  options: {
                    indexed: true,
                    nullable: true
                  }
                });
              })(key, relation);
            }
          }
          group = function(columns, callback) {
            var column_info, queue, result, _fn, _j, _len1;
            if (!table_exists) {
              return callback(null, {
                add: columns,
                update: []
              });
            }
            result = {
              add: [],
              update: []
            };
            queue = new Queue();
            _fn = function(column_info) {
              return queue.defer(function(callback) {
                return _this.hasColumn(column_info.key, function(err, exists) {
                  if (err) {
                    return callback(err);
                  }
                  (exists ? result.update : result.add).push(column_info);
                  return callback();
                });
              });
            };
            for (_j = 0, _len1 = columns.length; _j < _len1; _j++) {
              column_info = columns[_j];
              _fn(column_info);
            }
            return queue.await(function(err) {
              return callback(err, result);
            });
          };
          return group(columns, function(err, result) {
            if (err) {
              return callback(err);
            }
            return _this.connection.knex().schema[table_exists ? 'table' : 'createTable'](_this.table_name, function(table) {
              var column_info, _j, _k, _len1, _len2, _ref3, _ref4, _results;
              _ref3 = result.add;
              for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
                column_info = _ref3[_j];
                _this.addColumn(table, column_info);
              }
              _ref4 = result.update;
              _results = [];
              for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
                column_info = _ref4[_k];
                _results.push(_this.updateColumn(table, column_info));
              }
              return _results;
            }).exec(callback);
          });
        };
      })(this));
    };

    DatabaseTools.prototype.addColumn = function(table, column_info) {
      var column, column_args, constructor_options, _ref1;
      column_args = [column_info.key];
      constructor_options = _.pick(column_info.options, KNEX_COLUMN_OPTIONS);
      if (!_.isEmpty(constructor_options)) {
        if ((_ref1 = column_info.type) === 'float' || _ref1 === 'decimal') {
          column_args[1] = constructor_options['precision'];
          column_args[2] = constructor_options['scale'];
        } else {
          column_args[1] = _.values(constructor_options)[0];
        }
      }
      column = table[column_info.type].apply(table, column_args);
      if (!!column_info.options.nullable) {
        column.nullable();
      }
      if (!!column_info.options.primary) {
        column.primary();
      }
      if (!!column_info.options.indexed) {
        column.index();
      }
      if (!!column_info.options.unique) {
        column.unique();
      }
    };

    DatabaseTools.prototype.updateColumn = function(table, column_info) {};

    DatabaseTools.prototype.hasColumn = function(column, callback) {
      return this.connection.knex().schema.hasColumn(this.table_name, column).exec(callback);
    };

    DatabaseTools.prototype.hasTable = function(callback) {
      return this.connection.knex().schema.hasTable(this.table_name).exec(callback);
    };

    DatabaseTools.prototype.dropTable = function(callback) {
      return this.connection.knex().schema.dropTable(this.table_name).exec(callback);
    };

    DatabaseTools.prototype.dropTableIfExists = function(callback) {
      return this.connection.knex().schema.dropTableIfExists(this.table_name).exec(callback);
    };

    DatabaseTools.prototype.renameTable = function(to, callback) {
      return this.connection.knex().schema.renameTable(this.table_name, to).exec(callback);
    };

    return DatabaseTools;

  })();

}).call(this);
