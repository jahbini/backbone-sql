// Generated by CoffeeScript 1.9.2

/*
  backbone-sql.js 0.6.5
  Copyright (c) 2013 Vidigami - https://github.com/vidigami/backbone-sql
  License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

(function() {
  var DatabaseTools, KNEX_COLUMN_OPTIONS, KNEX_SKIP, KNEX_TYPES, Knex, Queue, _, _deprecate, knex_helpers, ref,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Knex = require('knex');

  ref = require('backbone-orm'), _ = ref._, Queue = ref.Queue;

  KNEX_COLUMN_OPTIONS = ['textType', 'length', 'precision', 'scale', 'value', 'values'];

  knex_helpers = require('knex/lib/helpers');

  KNEX_SKIP = ['The five argument join'];

  _deprecate = knex_helpers.deprecate;

  knex_helpers.deprecate = function(msg) {
    if (msg.indexOf(KNEX_SKIP) !== 0) {
      return _deprecate.apply(this, _.toArray(arguments));
    }
  };

  KNEX_TYPES = {
    datetime: 'dateTime',
    biginteger: 'bigInteger'
  };

  module.exports = DatabaseTools = (function() {
    function DatabaseTools(connection, table_name, schema, options) {
      this.connection = connection;
      this.table_name = table_name;
      this.schema = schema;
      if (options == null) {
        options = {};
      }
      this.renameTable = bind(this.renameTable, this);
      this.dropTableIfExists = bind(this.dropTableIfExists, this);
      this.dropTable = bind(this.dropTable, this);
      this.hasTable = bind(this.hasTable, this);
      this.hasColumn = bind(this.hasColumn, this);
      this.updateColumn = bind(this.updateColumn, this);
      this.addColumn = bind(this.addColumn, this);
      this.createOrUpdateTable = bind(this.createOrUpdateTable, this);
      this.ensureSchema = bind(this.ensureSchema, this);
      this.resetSchema = bind(this.resetSchema, this);
    }

    DatabaseTools.prototype.resetSchema = function(options, callback) {
      var queue, ref1;
      if (arguments.length === 1) {
        ref1 = [options, {}], callback = ref1[0], options = ref1[1];
      }
      if (this.resetting) {
        return callback();
      }
      this.resetting = true;
      queue = new Queue(1);
      queue.defer((function(_this) {
        return function(callback) {
          return _this.connection.knex().schema.dropTableIfExists(_this.table_name).exec(callback);
        };
      })(this));
      queue.defer((function(_this) {
        return function(callback) {
          var fn, i, join_queue, join_table, len, ref2;
          join_queue = new Queue(1);
          ref2 = _this.schema.joinTables();
          fn = function(join_table) {
            return join_queue.defer(function(callback) {
              return join_table.db().resetSchema(callback);
            });
          };
          for (i = 0, len = ref2.length; i < len; i++) {
            join_table = ref2[i];
            fn(join_table);
          }
          return join_queue.await(callback);
        };
      })(this));
      return queue.await((function(_this) {
        return function(err) {
          _this.resetting = false;
          if (err) {
            return callback(err);
          }
          return _this.ensureSchema(options, callback);
        };
      })(this));
    };

    DatabaseTools.prototype.ensureSchema = function(options, callback) {
      var queue, ref1;
      if (arguments.length === 1) {
        ref1 = [options, {}], callback = ref1[0], options = ref1[1];
      }
      if (this.ensuring) {
        return callback();
      }
      this.ensuring = true;
      queue = new Queue(1);
      queue.defer((function(_this) {
        return function(callback) {
          return _this.createOrUpdateTable(options, callback);
        };
      })(this));
      queue.defer((function(_this) {
        return function(callback) {
          var fn, i, join_queue, join_table, len, ref2;
          join_queue = new Queue(1);
          ref2 = _this.schema.joinTables();
          fn = function(join_table) {
            return join_queue.defer(function(callback) {
              return join_table.db().ensureSchema(callback);
            });
          };
          for (i = 0, len = ref2.length; i < len; i++) {
            join_table = ref2[i];
            fn(join_table);
          }
          return join_queue.await(callback);
        };
      })(this));
      return queue.await((function(_this) {
        return function(err) {
          _this.ensuring = false;
          return callback(err);
        };
      })(this));
    };

    DatabaseTools.prototype.createOrUpdateTable = function(options, callback) {
      this.hasTable((function(_this) {
        return function(err, table_exists) {
          var columns, field, group, i, key, len, override, ref1, ref2, relation, type;
          if (err) {
            return callback(err);
          }
          if (options.verbose) {
            console.log("Ensuring table: " + _this.table_name + " (exists: " + (!!table_exists) + ") with fields: '" + (_.keys(_this.schema.fields).join(', ')) + "' and relations: '" + (_.keys(_this.schema.relations).join(', ')) + "'");
          }
          columns = [];
          ref1 = _this.schema.columns();
          for (i = 0, len = ref1.length; i < len; i++) {
            key = ref1[i];
            if (field = _this.schema.fields[key]) {
              if (override = KNEX_TYPES[type = field.type.toLowerCase()]) {
                type = override;
              }
              columns.push({
                key: key,
                type: type,
                options: field
              });
            } else if (key === 'id') {
              columns.push({
                key: key,
                type: 'increments',
                options: {
                  indexed: true,
                  primary: true
                }
              });
            }
          }
          ref2 = _this.schema.relations;
          for (key in ref2) {
            relation = ref2[key];
            if ((relation.type === 'belongsTo') && !relation.isVirtual() && !relation.isEmbedded()) {
              (function(key, relation) {
                return columns.push({
                  key: relation.foreign_key,
                  type: 'integer',
                  options: {
                    indexed: true,
                    nullable: true
                  }
                });
              })(key, relation);
            }
          }
          group = function(columns, callback) {
            var column_info, fn, j, len1, queue, result;
            if (!table_exists) {
              return callback(null, {
                add: columns,
                update: []
              });
            }
            result = {
              add: [],
              update: []
            };
            queue = new Queue();
            fn = function(column_info) {
              return queue.defer(function(callback) {
                return _this.hasColumn(column_info.key, function(err, exists) {
                  if (err) {
                    return callback(err);
                  }
                  (exists ? result.update : result.add).push(column_info);
                  return callback();
                });
              });
            };
            for (j = 0, len1 = columns.length; j < len1; j++) {
              column_info = columns[j];
              fn(column_info);
            }
            return queue.await(function(err) {
              return callback(err, result);
            });
          };
          return group(columns, function(err, result) {
            if (err) {
              return callback(err);
            }
            return _this.connection.knex().schema[table_exists ? 'table' : 'createTable'](_this.table_name, function(table) {
              var column_info, j, k, len1, len2, ref3, ref4, results;
              ref3 = result.add;
              for (j = 0, len1 = ref3.length; j < len1; j++) {
                column_info = ref3[j];
                _this.addColumn(table, column_info);
              }
              ref4 = result.update;
              results = [];
              for (k = 0, len2 = ref4.length; k < len2; k++) {
                column_info = ref4[k];
                results.push(_this.updateColumn(table, column_info));
              }
              return results;
            }).exec(callback);
          });
        };
      })(this));
    };

    DatabaseTools.prototype.addColumn = function(table, column_info) {
      var column, column_args, constructor_options, ref1;
      column_args = [column_info.key];
      constructor_options = _.pick(column_info.options, KNEX_COLUMN_OPTIONS);
      if (!_.isEmpty(constructor_options)) {
        if ((ref1 = column_info.type) === 'float' || ref1 === 'decimal') {
          column_args[1] = constructor_options['precision'];
          column_args[2] = constructor_options['scale'];
        } else {
          column_args[1] = _.values(constructor_options)[0];
        }
      }
      column = table[column_info.type].apply(table, column_args);
      if (!!column_info.options.nullable) {
        column.nullable();
      }
      if (!!column_info.options.primary) {
        column.primary();
      }
      if (!!column_info.options.indexed) {
        column.index();
      }
      if (!!column_info.options.unique) {
        column.unique();
      }
    };

    DatabaseTools.prototype.updateColumn = function(table, column_info) {};

    DatabaseTools.prototype.hasColumn = function(column, callback) {
      return this.connection.knex().schema.hasColumn(this.table_name, column).exec(callback);
    };

    DatabaseTools.prototype.hasTable = function(callback) {
      return this.connection.knex().schema.hasTable(this.table_name).exec(callback);
    };

    DatabaseTools.prototype.dropTable = function(callback) {
      return this.connection.knex().schema.dropTable(this.table_name).exec(callback);
    };

    DatabaseTools.prototype.dropTableIfExists = function(callback) {
      return this.connection.knex().schema.dropTableIfExists(this.table_name).exec(callback);
    };

    DatabaseTools.prototype.renameTable = function(to, callback) {
      return this.connection.knex().schema.renameTable(this.table_name, to).exec(callback);
    };

    return DatabaseTools;

  })();

}).call(this);
